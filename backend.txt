"""Main FastAPI application"""
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from app.core.config import settings
from app.api.v1.router import router as api_v1_router
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan context"""
    # Startup
    logger.info(f"{settings.APP_NAME} v{settings.APP_VERSION} started")
    yield
    # Shutdown
    logger.info(f"{settings.APP_NAME} v{settings.APP_VERSION} shutdown")


# Create FastAPI application
app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description="API for anime data from AniList",
    lifespan=lifespan,
    debug=settings.DEBUG
)

# Root endpoint
@app.get("/")
async def root():
    """Root endpoint"""
    return {
        "message": "Vilibrity API",
        "version": "1.0.0",
        "status": "ok"
    }

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.get_cors_origins(),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(api_v1_router)


@app.get("/docs-info", tags=["info"])
async def api_info():
    """API information endpoint"""
    return {
        "title": settings.APP_NAME,
        "version": settings.APP_VERSION,
        "docs_url": "/docs",
        "redoc_url": "/redoc"
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app.main:app",
        host="0.0.0.0",
        port=8000,
        reload=True
    )

"""Service for interacting with AniList API"""
import httpx
import asyncio
from typing import Dict, List, Optional, Any
from datetime import datetime
from app.core.config import settings
from app.core.errors import AniListException
from app.schemas.anime import BannerAnime, CoverImage
import logging

logger = logging.getLogger(__name__)


class AniListService:
    """Service for AniList API interactions"""
    
    BASE_URL = settings.ANILIST_API_URL
    TIMEOUT = settings.ANILIST_TIMEOUT
    
    # GraphQL queries
    TRENDING_ANIME_QUERY = """
    query ($page: Int) {
        Page(page: $page, perPage: 10) {
            media(sort: TRENDING_DESC, type: ANIME, status: RELEASING) {
                id
                title {
                    romaji
                    english
                    native
                }
                description
                coverImage {
                    large
                    medium
                    color
                }
                bannerImage
                meanScore
                popularity
                status
                episodes
                genres
                startDate {
                    year
                    month
                    day
                }
            }
        }
    }
    """
    
    POPULAR_ANIME_QUERY = """
    query ($page: Int) {
        Page(page: $page, perPage: 10) {
            media(sort: POPULARITY_DESC, type: ANIME) {
                id
                title {
                    romaji
                    english
                }
                coverImage {
                    large
                }
                status
                episodes
            }
        }
    }
    """
    
    @classmethod
    async def _make_request(cls, query: str, variables: Optional[Dict] = None) -> Dict[str, Any]:
        """Make a request to AniList API"""
        try:
            async with httpx.AsyncClient(timeout=cls.TIMEOUT) as client:
                response = await client.post(
                    cls.BASE_URL,
                    json={"query": query, "variables": variables or {}},
                    headers={"Content-Type": "application/json"}
                )
                response.raise_for_status()
                data = response.json()
                
                if "errors" in data:
                    logger.error(f"AniList API Error: {data['errors']}")
                    raise AniListException(f"AniList API Error: {data['errors']}")
                
                return data.get("data", {})
        except httpx.HTTPError as e:
            logger.error(f"HTTP Error: {e}")
            raise AniListException(f"Failed to connect to AniList: {str(e)}")
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            raise AniListException(f"Unexpected error: {str(e)}")
    
    @classmethod
    async def get_trending_anime(cls, page: int = 1) -> List[BannerAnime]:
        """Get trending anime for banner"""
        try:
            data = await cls._make_request(cls.TRENDING_ANIME_QUERY, {"page": page})
            
            anime_list = []
            for media in data.get("Page", {}).get("media", []):
                try:
                    banner_anime = cls._parse_anime_to_banner(media)
                    anime_list.append(banner_anime)
                except Exception as e:
                    logger.warning(f"Failed to parse anime {media.get('id')}: {e}")
                    continue
            
            return anime_list
        except AniListException:
            raise
        except Exception as e:
            logger.error(f"Error getting trending anime: {e}")
            raise AniListException(f"Error getting trending anime: {str(e)}")
    
    @classmethod
    async def get_popular_anime(cls, page: int = 1) -> List[BannerAnime]:
        """Get popular anime"""
        try:
            data = await cls._make_request(cls.POPULAR_ANIME_QUERY, {"page": page})
            
            anime_list = []
            for media in data.get("Page", {}).get("media", []):
                try:
                    banner_anime = cls._parse_anime_to_banner(media)
                    anime_list.append(banner_anime)
                except Exception as e:
                    logger.warning(f"Failed to parse anime {media.get('id')}: {e}")
                    continue
            
            return anime_list
        except AniListException:
            raise
        except Exception as e:
            logger.error(f"Error getting popular anime: {e}")
            raise AniListException(f"Error getting popular anime: {str(e)}")
    
    @classmethod
    def _parse_anime_to_banner(cls, media: Dict) -> BannerAnime:
        """Parse AniList media data to BannerAnime schema"""
        
        # Extract title
        title_obj = media.get("title", {})
        title = title_obj.get("english") or title_obj.get("romaji") or "Unknown"
        
        # Extract cover image
        cover_image_data = media.get("coverImage", {})
        cover_image = CoverImage(
            large=cover_image_data.get("large"),
            medium=cover_image_data.get("medium"),
            color=cover_image_data.get("color")
        )
        
        # Extract start date
        start_date = None
        if media.get("startDate"):
            start_date_obj = media.get("startDate", {})
            year = start_date_obj.get("year")
            month = start_date_obj.get("month") or 1
            day = start_date_obj.get("day") or 1
            if year:
                start_date = f"{year}-{month:02d}-{day:02d}"
        
        return BannerAnime(
            id=media.get("id"),
            title=title,
            description=media.get("description"),
            coverImage=cover_image,
            bannerImage=media.get("bannerImage"),
            meanScore=media.get("meanScore"),
            popularity=media.get("popularity"),
            status=media.get("status"),
            episodes=media.get("episodes"),
            genres=media.get("genres", []),
            startDate=start_date
        )


# Create a singleton instance
anilist_service = AniListService()

"""Schemas for anime data"""
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime


class CoverImage(BaseModel):
    """Cover image data"""
    large: Optional[str] = None
    medium: Optional[str] = None
    color: Optional[str] = None

    class Config:
        from_attributes = True


class BannerAnime(BaseModel):
    """Anime data for home banner"""
    id: int
    title: str = Field(..., alias="title")
    description: Optional[str] = None
    coverImage: CoverImage
    bannerImage: Optional[str] = None
    meanScore: Optional[int] = None
    popularity: Optional[int] = None
    status: Optional[str] = None
    episodes: Optional[int] = None
    genres: Optional[List[str]] = []
    startDate: Optional[str] = None

    class Config:
        from_attributes = True
        populate_by_name = True


class BannerResponse(BaseModel):
    """Response for banner data"""
    trending: List[BannerAnime]
    updated_at: datetime


class AnimeListItem(BaseModel):
    """Single anime item for lists"""
    id: int
    title: str
    coverImage: CoverImage
    status: Optional[str] = None
    episodes: Optional[int] = None

    class Config:
        from_attributes = True
        populate_by_name = True

"""Application configuration"""
from pydantic_settings import BaseSettings
from pydantic import Field
from typing import Optional


class Settings(BaseSettings):
    """Application settings"""
    
    # App
    APP_NAME: str = "Vilibrity API"
    APP_VERSION: str = "1.0.0"
    DEBUG: bool = True
    ENV: str = "development"
    
    # Server
    HOST: str = "0.0.0.0"
    PORT: int = 8000
    
    # API
    API_V1_STR: str = "/api/v1"
    
    # CORS - Accept as string and convert to list
    CORS_ORIGINS: str = "http://localhost:5173,http://localhost:3000,http://127.0.0.1:5173,http://127.0.0.1:3000"
    
    # AniList API
    ANILIST_API_URL: str = "https://graphql.anilist.co"
    ANILIST_TIMEOUT: int = 10
    
    # External APIs
    EXTERNAL_API_TIMEOUT: int = 15
    
    class Config:
        env_file = ".env"
        case_sensitive = True
    
    def get_cors_origins(self) -> list:
        """Convert CORS_ORIGINS string to list"""
        if isinstance(self.CORS_ORIGINS, str):
            return [origin.strip() for origin in self.CORS_ORIGINS.split(",")]
        return self.CORS_ORIGINS


settings = Settings()

"""API v1 router with all endpoints"""
from fastapi import APIRouter
from app.api.v1.endpoints import anime, health

# Create main API v1 router
router = APIRouter(prefix="/api/v1")

# Include endpoint routers
router.include_router(anime.router)
router.include_router(health.router)


"""Health check endpoints"""
from fastapi import APIRouter

router = APIRouter(tags=["health"])


@router.get("/")
async def root():
    """Root endpoint"""
    return {
        "message": "Vilibrity API",
        "version": "1.0.0",
        "status": "ok"
    }


@router.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "version": "1.0.0"
    }

"""Anime endpoints"""
from fastapi import APIRouter, HTTPException, Query
from typing import List
from app.schemas.anime import BannerAnime, BannerResponse
from app.services.anilist_service import anilist_service
from app.core.errors import AniListException
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/anime", tags=["anime"])


@router.get("/trending", response_model=BannerResponse)
async def get_trending_anime(page: int = Query(1, ge=1)):
    """
    Get trending anime for home banner
    
    - **page**: Page number (default: 1)
    """
    try:
        anime_list = await anilist_service.get_trending_anime(page=page)
        return BannerResponse(
            trending=anime_list,
            updated_at=datetime.now()
        )
    except AniListException as e:
        logger.error(f"AniList error: {e}")
        raise HTTPException(status_code=503, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")


@router.get("/popular", response_model=List[BannerAnime])
async def get_popular_anime(page: int = Query(1, ge=1)):
    """
    Get popular anime
    
    - **page**: Page number (default: 1)
    """
    try:
        anime_list = await anilist_service.get_popular_anime(page=page)
        return anime_list
    except AniListException as e:
        logger.error(f"AniList error: {e}")
        raise HTTPException(status_code=503, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
